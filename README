DLM Manager - UXP1A, 2012

Takto wszystko fajnie, tylko 3 male propozycje:
1. Język. Wszystko piszmy po angielsku, kod, komunikaty, komentarze, zeby bylo spojnie.
   Ew. komentarze do nas/tymczasowe moga byc po polsku.
   
   [pjarosik] ja to co zrobiłem na razie, nie ma żadnego sensu, tylko próbowałem jakoś to rozsądnie
   rozdzielić. komentarze są miejscami po polsku, bo myślałem, że to co tam napisałem sam zaraz poprawię, ale jest póki co jeszcze parę innych
   rzeczy do zrobienia, więc dałem sobie spokój. Ten projekt jest prosty, można go dobrze i szybko zrobić przy odpowiednim podziale tym co kto robi,
   tylko jest parę kwestii do rozwiązania (patrz niżej).
   
2. Komentarze nagłówkowe. @class może być, @brief też, @author bym wyrzucił ew. na koncu sie dopisze ladnie wszystkich, 
   @version gdzieś widziałem, tak naprawdę to @date może zostać i to będzie nasze version. Czyli class, brief, date.
   
3. Namespace. 
   Albo robmy using namespace coś albo coś::. Widze, ze dla std jest ta druga taktyka stosowana, dobrze.
   To dla dlm tez tak zrobmy.
   
   [pjarosik] Wg mnie jedynym poprawnym rozwiązaniem jest: gdy używamy czegoś z jakiegoś namespace'a w plikach nagłówkowych, korzystamy
              wyłącznie z ::. W przypadku implementacji (w plikach .cpp) można sobie używać using namespace, ale to już jak 
              komu wygodniej, możliwe, że ja rzeczywiście byłem miejscami niekonsekwentny. W plikach nagłówkowych nie powinno się używać using namespace, 
              bo są one include'owane, czyli jak ktoś włączy sobie ten plik do swojego pliku, to automatycznie także ma włączone using namespace.
              
Kwestie do rozwiązania:
- ten dlm będzie tak na prawdę prostą konsolą, co jest trochę kłoptliwe. Bo jeżeli uruchomimy jakiś proces pochodny, to jego stdin stdout jest takie jak procesu 
  macierzystego a to powoduje, że jak uruchomimy kilka procesów, to ich komunikaty się będą przpeplatać, przy okazji zamazując miejsce do pisania w konsoli.
  Trzeba to jakoś inaczej zrobić, żeby było to czytelne.
  
  Rozwiazanie: Dla każdego procesu osobna konsolka, xterm -e program [ arguments ... ]. 
  Albo np. gnome-terminal, w każdym razie nazwa programu powinna być na zewnątrz w pliczku config.
    
- jak przekazywać deskryptory potoków do procesu potomnego. Najprostszy pomysł to przekazywac jest w argv procesu potomnego (np. na końcu argv) tylko to trochę jest
  nieeleganckie.
  
  Faktycznie trochę nieeleganckie, bo program procesu może po prostu chcieć używać sobie argv na np. jakieś flagi.
  Póki co nie mam lepszego pomysłu.
  
- jak zrealizować lock managera - moim zdaniem powinna ona trzymać dla każdego zasobu dwie struktury: pierwsza: lista dotyczy locków, które zostały
  zaakceptowane (tzn. procesy je zakładające się nie zablokowały) - resource id ->  (pid, rodzaj_locka); druga: kolejka FIFO trójek (pid, rodzaj_locka, zmienna
  warunkowa) określająca procesy które się zablokowały na zasobie. Gdy jest wykonywany DLM_lock, sprawdzane jest czy podany rodzaj locka jest kompatybilny z innymi,
  jeżeli tak, to dodaj do pierwszej listy, jeżeli nie to dodaj na koniec kolejki fifo. DLM_unlock - usuń element z listy akceptowanych, sprawdź czy któryś z listy
  czekających jest kompatybilny, jeżeli tak to go signal jego zmienną warunkową i przenieś go do listy locków zaakceptowanych.
  
  Ok, FIFO weźmie się z <queue>, no a liste z <list>.
  FIFO nie weźmie się z <queue>, bo nie oferuje operacji na elemtach wewnątrz, także też zrobiłem to jako listę.
  
Wydawało mi się, że bylismy dość precyzjni, jesli chodzi o konwencję, ale jesteśmy w paru aspektach niekonsekwentni:

1. Nazwy funkcji. Blinowski sugerował np. DLM_lock(), zatem trzymajmy się tej konwencji, nie camelCase().
[Piotrek]: to była moja sugestia i dotyczyła tego, że: nazwy funkcji pisane z podkreślnikiem (tak jak chce Blinowski no i jak w 
większości projektów w C jest) metody: camel case'm. W sumie dla mnie to może być dowolnie, jeżeli funkcje i metody mają być
traktowane jednakowo, to bym sugerował użycie wszędzie camel case. 
[Adam]: Też preferuje camelCase ponad_tym, ale Blinowski niejako narzucił konwencję pisząc, że ma być DLM_lock(), no i moze jest to 
		sluszne, bo to bardziej w stylu C. A jak metody piszemy tak a funkcje inaczej to wygląda to niespójnie, jakbysmy robili byle jak.
		Zrobmy wszedzie_tak i juz.

2. Nazwy zmiennych. Tak samo, ta_konwencja.
[Piotrek]: to co wyżej: zmienne lokalne (w tym argumenty funkcji/metod)/globalne (których nie powinno się w normalnych programach używać) pisane z podkreśleniem, składowe klas - camel case. Może być jednak jak chcecie.
3. Widzę, że Piotrek głównie tak robi. Dodawanie _ na końcu zmiennych prywatnych. Moim zdaniem brzydko to wygląda, a zysk jest żaden. 
   Ponadto po zmienieniu zasięgu zmiennej trzeba zmieniać te "_". Widziałem też to _ ale na początku.
   W czym _ jest lepsze na początku od na końcu? Podczas pisania piszemy sobie "_" i już nam dopełnia do reszty nazwy, taki dodatkowy plus.
   Ale ja bym proponował zrezygnować z takich dekoracji, po prostu nazwy zmiennych i już.  
[Piotrek]: _* lepiej nie używać, bo duża część używanych przez kompilator tego używa. 
[Adam]: Hehe, jak powiedział Dawidczyk, "no i co z tego?" Kompilator i tak sobie poradzi, nie będzie konfliktów. Zobacz, że mamy też namespace ;)
Co do *_ - jest to przydatne szczególnie, gdy z klasy 
korzysta aplikacja wielowątkowa, i gdy w implementowanych metodach zmienia się zawartość składowych (nie tylko prywatnych, chociaż klasa powinna
mieć niestatyczne jedynie pola prywatne) - wówczas od razu widać, na które miejsca trzeba uważać, przydatne też jest gdy szukamy błędu, który nie
jest powtarzalny (wtedy zazwyczaj nie pozostaje nic innego jak czytać kod od nowa) - wtedy od razu widać, które zmienne są bezpieczne, a które nie.
W Javie jest prosto, jak metoda będzie wykorzystywana przez wiele wątków to dajemy synchronized (albo robimy sam blok synchronized), dlatego 
Dawidczyk objechał też kiedyś Bemka za coś podobnego (chociaż niesłusznie, bo synchronized jest często strzelaniem z armaty do muchy).
A skąd te podkreślenie - po prostu zaczerpnąłem to z ZPRów od Nowaka, który tak proponował oznaczać pola klas. Mi się coś takiego podoba, 
jednak to jest tylko konwencja - podkreślenia są tworzone u mnie z automatu (tak samo jak te wszystkie doxygenowe komentarze). 
Jeżeli trzeba to mogę to usunąć.
[Adam]: Robiac 1 projekt z danym rozwiazaniem ciezko je okreslic jako "sprawdzone, przetestowane, lepsze" itp.
        Pamietam jak kiedys ludzie strasznie jarali się notacją węgierską. Byly flame-war'y coraz wiecej kodow bylo tak pisanych.
        Ale czas weryfikuje - i co mamy dzis? Notacja wegierska tak naprawde nie jest taka super, podobnie jak _, nie widac zyskow,
        a strata jest - spada czytelnosc kodu. W dobie obecnych IDE gdzie wystarczy przytrzymac kursor na zmienna i wiemy wszystko zysk maleje do zera.
        Ja rozumiem, ze kiedys, ktos kto pisal w vi, docenial silniej te zalety i moglo to byc ok. Warto tez zauwazyc, ze my praktycznie nie mamy zmiennych
        publicznych. Wiec kazda trzeba "rozrozniac" piszac np. to _.
4. Gwiazdkę przy wskaznikach proponuje stawiac zawsze przy nazwie zmiennej czyli void *ptr, nie void* ptr.
   Jeśli funkcja zwraca wskaźnik to tak: void* f(), nie void *f().
   Aha i to samo z referencją, &.
[Piotrek]: tutej racja, do drugiego sam sie nie stosowałem ;) 
5. // Komentarze jednolinijkowe ze spacją po "/" i najlepiej pełnym zdaniem z kropeczką.
[Piotrek]: oj tam oj tam, i tak nikt tego kodu (łącznie z Blinowskim) pewnie nie będzie czytał... no a tak na poważnie to tutej Adam 
też ma rację (kajam się i ubolewam ;) ). SWOJĄ DROGĄ TEN OSTATNI KOMENTARZ TRZEBA BĘDZIE USUNĄĆ Z README PRZED ODDANIEM 
PROJEKTU (a może jednak Blinowski będzie czytal?! :) )
[Adam]: Tak, mysle ze trzeba bedzie to readme usunąć, zbyt ciekawa lektura, ale dobrze ze powstalo, taki swoisty czat.
        Last but not least: to nie sa bledy, wiec nie trzeba sie kajac czy ubolowac, po prostu konstruktywnie sobie gadamy o mozliwych rozwiazaniach, na luzaczku.
        Z 99% tego co piszesz zgadzam się calkowicie, a jak czegos nie rozumiem czy mam inne doswiadczenia to wole pogadac, wymienic sie tymi doswiadczeniami,
        bo moze cos dobrego z tego wyjsc.